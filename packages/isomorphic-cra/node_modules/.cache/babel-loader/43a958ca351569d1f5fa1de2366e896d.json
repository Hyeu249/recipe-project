{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isFinite3 = require('lodash/isFinite');\n\nvar _isFinite4 = _interopRequireDefault(_isFinite3);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _indexUtils = require('../core/indexUtils');\n\nvar _createConnector = require('../core/createConnector');\n\nvar _createConnector2 = _interopRequireDefault(_createConnector);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attributeName` prop must be holding numerical values.\n * @propType {string} attributeName - Name of the attribute for faceting\n * @propType {{min: number, max: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=2] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n */\n\n\nfunction getId(props) {\n  return props.attributeName;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n  var min = void 0;\n\n  if ((0, _isFinite4.default)(boundaries.min)) {\n    min = boundaries.min;\n  } else if ((0, _isFinite4.default)(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max = void 0;\n\n  if ((0, _isFinite4.default)(boundaries.max)) {\n    max = boundaries.max;\n  } else if ((0, _isFinite4.default)(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var refinement = (0, _indexUtils.getCurrentRefinementValue)(props, searchState, context, namespace + '.' + getId(props), {}, function (currentRefinement) {\n    var min = currentRefinement.min,\n        max = currentRefinement.max;\n\n    if (typeof min === 'string') {\n      min = parseInt(min, 10);\n    }\n\n    if (typeof max === 'string') {\n      max = parseInt(max, 10);\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  });\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next = void 0;\n\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n  var isNextMinValid = isMinReset || (0, _isFinite4.default)(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || (0, _isFinite4.default)(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return (0, _indexUtils.refineValue)(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return (0, _indexUtils.cleanUpValue)(searchState, context, namespace + '.' + getId(props));\n}\n\nexports.default = (0, _createConnector2.default)({\n  displayName: 'AlgoliaRange',\n  propTypes: {\n    id: _propTypes2.default.string,\n    attributeName: _propTypes2.default.string.isRequired,\n    defaultRefinement: _propTypes2.default.shape({\n      min: _propTypes2.default.number.isRequired,\n      max: _propTypes2.default.number.isRequired\n    }),\n    min: _propTypes2.default.number,\n    max: _propTypes2.default.number,\n    precision: _propTypes2.default.number\n  },\n  defaultProps: {\n    precision: 2\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attributeName = props.attributeName,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n    var results = (0, _indexUtils.getResults)(searchResults, this.context);\n    var stats = results ? results.getFacetStats(attributeName) || {} : {};\n    var count = results ? results.getFacetValues(attributeName).map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    }) : [];\n\n    var _getCurrentRange = getCurrentRange({\n      min: minBound,\n      max: maxBound\n    }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max; // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behaviour change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n\n    var _getCurrentRefinement = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        valueMin = _getCurrentRefinement.min,\n        valueMax = _getCurrentRefinement.max;\n\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: {\n        min: valueMin === undefined ? rangeMin : valueMin,\n        max: valueMax === undefined ? rangeMax : valueMax\n      },\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, this.context);\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, this.context);\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attributeName = props.attributeName;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        min = _getCurrentRefinement2.min,\n        max = _getCurrentRefinement2.max;\n\n    params = params.addDisjunctiveFacet(attributeName);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attributeName, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attributeName, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _currentRange = this._currentRange,\n        minRange = _currentRange.min,\n        maxRange = _currentRange.max;\n\n    var _getCurrentRefinement3 = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        minValue = _getCurrentRefinement3.min,\n        maxValue = _getCurrentRefinement3.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? minValue + ' <= ' : '', props.attributeName, hasMax ? ' <= ' + maxValue : ''];\n      items.push({\n        label: fragments.join(''),\n        attributeName: props.attributeName,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, _this.context);\n        },\n        currentRefinement: {\n          min: minValue,\n          max: maxValue\n        }\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: (0, _indexUtils.getIndex)(this.context),\n      items: items\n    };\n  }\n});","map":{"version":3,"sources":["/home/tht-hieu/Desktop/recipe-project/node_modules/react-instantsearch/src/connectors/connectRange.js"],"names":["Object","defineProperty","exports","value","_isFinite3","require","_isFinite4","_interopRequireDefault","_propTypes","_propTypes2","_indexUtils","_createConnector","_createConnector2","obj","__esModule","default","_defineProperty","key","enumerable","configurable","writable","getId","props","attributeName","namespace","getCurrentRange","boundaries","stats","precision","pow","Math","min","undefined","max","floor","ceil","getCurrentRefinement","searchState","currentRange","context","refinement","getCurrentRefinementValue","currentRefinement","parseInt","hasMinBound","hasMaxBound","hasMinRefinment","hasMaxRefinment","Error","nextValueForRefinement","hasBound","isReset","range","next","_refine","nextRefinement","nextMin","nextMax","currentMinRange","currentMaxRange","isMinReset","isMaxReset","nextMinAsNumber","parseFloat","nextMaxAsNumber","isNextMinValid","isNextMaxValid","id","resetPage","nextValue","refineValue","_cleanUp","cleanUpValue","displayName","propTypes","string","isRequired","defaultRefinement","shape","number","defaultProps","getProvidedProps","searchResults","minBound","maxBound","results","getResults","getFacetStats","count","getFacetValues","map","v","name","_getCurrentRange","rangeMin","rangeMax","_currentRange","_getCurrentRefinement","valueMin","valueMax","canRefine","length","refine","cleanUp","getSearchParameters","params","_getCurrentRefinement2","addDisjunctiveFacet","addNumericRefinement","getMetadata","_this","minRange","maxRange","_getCurrentRefinement3","minValue","maxValue","items","hasMin","hasMax","shouldDisplayMinLabel","shouldDisplayMaxLabel","fragments","push","label","join","nextState","index","getIndex"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isFinite3 = require('lodash/isFinite');\n\nvar _isFinite4 = _interopRequireDefault(_isFinite3);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _indexUtils = require('../core/indexUtils');\n\nvar _createConnector = require('../core/createConnector');\n\nvar _createConnector2 = _interopRequireDefault(_createConnector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attributeName` prop must be holding numerical values.\n * @propType {string} attributeName - Name of the attribute for faceting\n * @propType {{min: number, max: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=2] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n */\n\nfunction getId(props) {\n  return props.attributeName;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n\n  var min = void 0;\n  if ((0, _isFinite4.default)(boundaries.min)) {\n    min = boundaries.min;\n  } else if ((0, _isFinite4.default)(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max = void 0;\n  if ((0, _isFinite4.default)(boundaries.max)) {\n    max = boundaries.max;\n  } else if ((0, _isFinite4.default)(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var refinement = (0, _indexUtils.getCurrentRefinementValue)(props, searchState, context, namespace + '.' + getId(props), {}, function (currentRefinement) {\n    var min = currentRefinement.min,\n        max = currentRefinement.max;\n\n    if (typeof min === 'string') {\n      min = parseInt(min, 10);\n    }\n    if (typeof max === 'string') {\n      max = parseInt(max, 10);\n    }\n    return { min: min, max: max };\n  });\n\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next = void 0;\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n\n\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n\n  var isNextMinValid = isMinReset || (0, _isFinite4.default)(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || (0, _isFinite4.default)(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return (0, _indexUtils.refineValue)(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return (0, _indexUtils.cleanUpValue)(searchState, context, namespace + '.' + getId(props));\n}\n\nexports.default = (0, _createConnector2.default)({\n  displayName: 'AlgoliaRange',\n\n  propTypes: {\n    id: _propTypes2.default.string,\n    attributeName: _propTypes2.default.string.isRequired,\n    defaultRefinement: _propTypes2.default.shape({\n      min: _propTypes2.default.number.isRequired,\n      max: _propTypes2.default.number.isRequired\n    }),\n    min: _propTypes2.default.number,\n    max: _propTypes2.default.number,\n    precision: _propTypes2.default.number\n  },\n\n  defaultProps: {\n    precision: 2\n  },\n\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attributeName = props.attributeName,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n\n    var results = (0, _indexUtils.getResults)(searchResults, this.context);\n    var stats = results ? results.getFacetStats(attributeName) || {} : {};\n    var count = results ? results.getFacetValues(attributeName).map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    }) : [];\n\n    var _getCurrentRange = getCurrentRange({ min: minBound, max: maxBound }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max;\n\n    // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behaviour change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n\n    var _getCurrentRefinement = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        valueMin = _getCurrentRefinement.min,\n        valueMax = _getCurrentRefinement.max;\n\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: {\n        min: valueMin === undefined ? rangeMin : valueMin,\n        max: valueMax === undefined ? rangeMax : valueMax\n      },\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, this.context);\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, this.context);\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attributeName = props.attributeName;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        min = _getCurrentRefinement2.min,\n        max = _getCurrentRefinement2.max;\n\n    params = params.addDisjunctiveFacet(attributeName);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attributeName, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attributeName, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _currentRange = this._currentRange,\n        minRange = _currentRange.min,\n        maxRange = _currentRange.max;\n\n    var _getCurrentRefinement3 = getCurrentRefinement(props, searchState, this._currentRange, this.context),\n        minValue = _getCurrentRefinement3.min,\n        maxValue = _getCurrentRefinement3.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? minValue + ' <= ' : '', props.attributeName, hasMax ? ' <= ' + maxValue : ''];\n\n      items.push({\n        label: fragments.join(''),\n        attributeName: props.attributeName,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, _this.context);\n        },\n        currentRefinement: {\n          min: minValue,\n          max: maxValue\n        }\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: (0, _indexUtils.getIndex)(this.context),\n      items: items\n    };\n  }\n});"]},"metadata":{},"sourceType":"script"}